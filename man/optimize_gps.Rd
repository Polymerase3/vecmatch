% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize_gps.R
\name{optimize_gps}
\alias{optimize_gps}
\title{Optimize the matching process}
\usage{
optimize_gps(
  data = NULL,
  formula,
  ordinal_treat = NULL,
  n_iter = 1000,
  n_cores = 1,
  opt_args = NULL
)
}
\arguments{
\item{data}{a data frame with columns specified in the \code{formula} argument. If
\code{opt_args} is provided, the data provided within it must be the same as the
data passed to the \code{optimize_gps()} function.}

\item{formula}{a valid R formula, which describes the model used to
calculating the probabilities of receiving a treatment. The variable to be
balanced is on the left side, while the covariates used to predict the
treatment variable are on the right side. To define the interactions
between covariates, use \code{*}. For more details, refer to \code{\link[stats:formula]{stats::formula()}}.
If \code{opt_args} is provided, the formula contained within it must be the same
as the formula passed to the \code{optimize_gps()} function.}

\item{ordinal_treat}{an atomic vector of the length equal to the length of
unique levels of the treatment variable. Confirms, that the treatment
variable is an ordinal variable and adjusts its levels, to the order of
levels specified in the argument. Is a call to the function
\verb{factor(treat, levels = ordinal_treat, ordered = TRUE}. It will be passed
to the \code{estimate_gps()} function directly. If \code{NULL}, then the \code{polr} GPS
estimation method will be ignored and excluded from the search.}

\item{n_iter}{Integer. The number of unique combinations of all optimization
parameters to evaluate during the optimization process. It is recommended
to start with the default value and increase gradually based on the
complexity of the problem and available computational resources. Larger
numbers of combinations generally lead to better optimization results but
also increase computation time. The efficiency and speed of the
optimization improve when using multiple cores (\code{n_cores}), especially with
higher numbers of iterations. Using a high number of cores with a low
number of iterations can introduce overhead, potentially resulting in
longer execution times. Overall, execution time depends heavily on the
number of iterations, number of cores, and the size and complexity of the
dataset.}

\item{n_cores}{Integer. The number of CPU cores allocated for parallel
computation. If \code{n_cores > 1}, a parallel backend is automatically
registered using \code{\link[future:multisession]{future::multisession()}}. \strong{Warning:} Using multiple
cores can significantly increase RAM usage, especially when handling large
datasets and/or a high number of iterations. Users with limited RAM (e.g.,
16 or 32 GB) should monitor their system resources closely to prevent
crashes or slowdowns. The multisession backend duplicates the R session
across workers, which can be memory-intensive. It is advisable to balance
the number of cores with available memory and dataset size to optimize
performance and stability. The function is self-contained and performs
memory cleanup after execution to help manage resources efficiently.}

\item{opt_args}{An object of class \code{"opt_args"} containing optimization
arguments and parameter settings. See the documentation of
\code{\link[=make_opt_args]{make_opt_args()}} for details on creating and customizing this object.}
}
\value{
An object of class \code{best_opt_result}. The main part of the obvject is a data frame with the optimization results.
For the datiled explanation of the particular columns refer to the \emph{Details} section.
}
\description{
The \code{optimize_gps()} function performs a random search algorithm
to optimize parameters used in \code{match_gps()} and \code{estimate_gps()}. It aims
to identify parameter combinations that maximize the percentage of matched
samples (\%matched) while minimizing the standardized mean difference (SMD),
thereby improving matching quality. The function supports parallel
execution through the \code{foreach} and \code{future} packages, enabling
multithreaded optimization to significantly accelerate complex parameter
searches.
}
\details{
The result of the \code{optimize_gps()} function is an S3 object of class
\code{best_opt_result}. Its core component is a \code{data.frame} that contains the
parameter specifications of the best-performing models identified during the
optimization process.

The optimization results are categorized into seven bins based on the maximum
standardized mean difference (SMD):
\itemize{
\item 0.00–0.05
\item 0.05–0.10
\item 0.10–0.15
\item 0.15–0.20
\item 0.20–0.25
\item 0.25–0.30
\item more than 0.30
}

Within each SMD group, the combination(s) of parameters with the highest
\code{perc_matched} (i.e., the percentage of matched samples) is selected. If
multiple combinations have identical \code{smd} and \code{perc_matched} values—which is
common—all such models are retained in the final \code{data.frame}.

The resulting data frame has 15 columns describing the matching and GPS
estimation setup:
\itemize{
\item \code{method_match}: Matching method used in \code{\link[=match_gps]{match_gps()}}. Currently supports \code{"nnm"} and \code{"fullopt"}.
\item \code{caliper}: Caliper distance used in \code{\link[=match_gps]{match_gps()}}.
\item \code{order}: Sorting order of GPS values prior to matching.
\item \code{kmeans_cluster}: Number of k-means clusters. Should not exceed the number of treatment levels.
\item \code{replace}: Whether replacement was used during matching (only defined if \code{method_match == "nnm"}, else \code{NA}).
\item \code{ties}: Handling of ties in nearest-neighbor matching (only defined if \code{method_match == "nnm"}).
\item \code{ratio}: Ratio of controls to treated in matching (only defined if \code{method_match == "nnm"}).
\item \code{min_controls} / \code{max_controls}: Control limits for full matching (only defined if \code{method_match == "fullopt"}).
\item \code{reference}: Reference treatment group used in both \code{\link[=estimate_gps]{estimate_gps()}} and \code{\link[=match_gps]{match_gps()}}.
\item \code{perc_matched}: Percentage of matched samples (from \code{\link[=balqual]{balqual()}}).
\item \code{smd}: Maximum standardized mean difference (from \code{\link[=balqual]{balqual()}}).
\item \code{method_gps}: Method used to estimate GPS in \code{\link[=estimate_gps]{estimate_gps()}}.
\item \code{link}: Link function used in the GPS model.
\item \code{smd_group}: Category corresponding to the SMD range bin.
\item \code{p_treatlevel}: where \code{treatlevel} are unique levels of the treatment variable. Several columns representing the percentage of matched samples for each group (this means number of matched samples / number of all samples in the groups * 100).
}

The \code{best_opt_result} object includes a custom \code{print()} method that
summarizes the outcome. This summary displays:
\itemize{
\item The number of unique optimal parameter sets within each \code{smd_group}
\item The corresponding SMDs and percentage matched
\item The total number of combinations tested
\item The total optimization runtime
}

Only the top-performing combinations per \code{smd_group}—as described—are shown
in the printed summary.
}
